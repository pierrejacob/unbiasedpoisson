## The model and data are taken from Germán Rodríguez' course on multilevel models;
## https://grodri.github.io/multilevel/hospmle
## https://data.princeton.edu/pop510/hospmle
## and https://data.princeton.edu/pop510/hospStan

## Taken from first link above:
## "We will illustrate random intercept logit models using data from Lillard and Panis (2000)
## on 1060 births to 501 mothers. The outcome of interest is whether the birth was delivered 
## in a hospital or elsewhere. The predictors include the log of income 'loginc', the distance
## to the nearest hospital 'distance', and two indicators of mothers’s education: 'dropout' for less 
## than high school and 'college' for college graduates, so high school or
## some college is the reference cell."

## 
set.seed(1)

## update; downloaded from https://grodri.github.io/multilevel/hospmle
hosp <- read.table("inst/hospital.dat", header = FALSE)
# hosp <- read.table("https://data.princeton.edu/pop510/hospital.dat", header = FALSE)
names(hosp) <- c("hosp","loginc","distance","dropout","college","mother")

## now Stan code taken from  https://data.princeton.edu/pop510/hospStan
hosp_code <- '
data {
    int N; // number of obs (pregnancies)
    int M; // number of groups (women)
    int K; // number of predictors
    
    int y[N]; // outcome
    row_vector[K] x[N]; // predictors
    int g[N];    // map obs to groups (pregnancies to women)
}
parameters {
    real alpha;
    real a[M]; 
    vector[K] beta;
    real<lower=0,upper=10> sigma;  
}
model {
  alpha ~ normal(0,100);
  a ~ normal(0,sigma);
  beta ~ normal(0,100);
  for(n in 1:N) {
    y[n] ~ bernoulli(inv_logit( alpha + a[g[n]] + x[n]*beta));
  }
}
'
## prepare the data 
hosp_data <- list(N=nrow(hosp),M=501,K=4,y=hosp[,1],x=hosp[,2:5],g=hosp[,6])
## load Stan
library(rstan)
## use all cores but 2
options(mc.cores = parallel::detectCores()-2)
## warm-up and total number of iterations
warmup <- 1000
iter <- 2000
## compile model and run MCMC
# hfit <- stan(model_code=hosp_code, model_name="hospitals", data=hosp_data,
#              warmup = warmup, iter=iter, chains=2, sample_file = "sample_file_hosp")

load(file = "output/hfit.rds")

# hfit2 <- hfit
hfit2 <- stan(model_code=hosp_code, model_name="hospitals", fit = hfit, data=hosp_data,
             warmup = 1, iter=2, chains=2, sample_file = "output/sample_file_hosp")


postsamples <- as.matrix(hfit)
dim(postsamples)
## transform samples so that they are "unconstrained" (i.e. take values in all of R^d)
unconstr_posterior <- postsamples[,1:(dim(postsamples)[2]-1)]
unconstr_posterior[,dim(unconstr_posterior)[2]] <- log(unconstr_posterior[,dim(unconstr_posterior)[2]])
## load inverse of mass matrix, i.e. an approximation of the diagonal elements of the posterior covariance matrix
## this was found on https://discourse.mc-stan.org/t/extracting-the-mass-matrix-euclidean-metric-in-rstan/9897 
datadump <- readLines("output/sample_file_hosp_1.csv") # read the output generated by the call to 'stan'
massmatindex <- grep("^# Diagonal elements", datadump) + 1 # one line after the line "# Diagonal elements of inverse mass matrix:"
yy <- unlist(strsplit(datadump[massmatindex], split=", "))
yy[1] <- substring(yy[1], 3) # eliminate the '#' symbol 
invmassdiag <- as.numeric(yy)
## mass matrix and its sqrt, for convenience
massdiag <- 1/invmassdiag
sqrt_massdiag <- sqrt(massdiag)

## get the stepsize for HMC 
sampler_params <- get_sampler_params(hfit, inc_warmup = TRUE)
stepsize <- as.numeric(sampler_params[[1]][(warmup+1),2])
## target dimension
target_dim <- get_num_upars(hfit2)
## function to evaluate log density on unconstrained space
target <- function(x) log_prob(hfit2, x)
## function to evaluate gradient of log density on unconstrained space
gradtarget <- function(x) grad_log_prob(hfit2, x)
## estimated posterior moments, on the unconstrained space
postcov <- cov(as.matrix(unconstr_posterior))
postmean <- colMeans(as.matrix(unconstr_posterior))


## define diagonal proposal covariance
Sigma_prop <- diag(postcov)
Sigma_prop_chol <- sqrt(Sigma_prop)

## define max number of leapfrog steps
Lmax <- 20
## define scalar stepsize
stepsize <- 0.2

## test function
h <- function(x){
  return(x[506])
}

## 506 is the coefficient associated with the covariate `college`
## For reference the result of `glmer` (https://grodri.github.io/multilevel/hospmle)
## is as follows:
##
# Fixed effects:
#   Estimate Std. Error z value Pr(>|z|)    
# (Intercept) -3.29448    0.46666  -7.060 1.67e-12 ***
#   loginc       0.55040    0.07094   7.759 8.59e-15 ***
#   distance    -0.07742    0.03169  -2.443  0.01456 *  
#   dropout     -1.94727    0.24439  -7.968 1.61e-15 ***
# **college**   1.02322    0.37259   2.746  0.00603 ** 


## initial distribution of the chains
library(mvtnorm)
rinit <- function(x){
  if (missing(x)){
    position <- mvtnorm::rmvnorm(1, postmean, postcov)[1,]
    current_pdf <- target(position)
    grad_pdf <- gradtarget(position)
    return(list(position = position, current_pdf = current_pdf, grad_pdf = grad_pdf))
  } else {
    position <- x
    current_pdf <- target(position)
    grad_pdf <- gradtarget(position)
    return(list(position = position, current_pdf = current_pdf, grad_pdf = grad_pdf))
  }
}

# ## arbitrary point used in the definition of the fishy function
state_x_0 <- rinit()
x_0 <- state_x_0$position

